---
import fs from "node:fs";
import path from "node:path";

// CHANGE THIS if you keep your CSV elsewhere:
const csvFile = new URL("../data/cifs.csv", import.meta.url);

// ---- Minimal CSV parser that supports quoted fields ----
function parseCSV(text) {
  const rows = [];
  let i = 0, field = "", row = [], inQuotes = false;
  while (i <= text.length) {
    const c = text[i] ?? "\n"; // force flush on end
    const next = text[i + 1];

    if (inQuotes) {
      if (c === '"' && next === '"') { field += '"'; i += 2; continue; }
      if (c === '"') { inQuotes = false; i++; continue; }
      field += c; i++; continue;
    }

    if (c === '"') { inQuotes = true; i++; continue; }
    if (c === ",") { row.push(field.trim()); field = ""; i++; continue; }
    if (c === "\n" || c === "\r") {
      // handle \r\n
      if (c === "\r" && next === "\n") i++;
      row.push(field.trim()); field = "";
      // ignore completely empty last line
      if (!(row.length === 1 && row[0] === "")) rows.push(row);
      row = []; i++; continue;
    }

    field += c; i++;
  }
  // header → objects
  if (rows.length === 0) return [];
  const header = rows[0].map(h => h.toLowerCase());
  return rows.slice(1).map(r => {
    const obj = {};
    header.forEach((h, idx) => (obj[h] = r[idx] ?? ""));
    return obj;
  });
}

const csvText = fs.readFileSync(csvFile, "utf-8");
const itemsRaw = parseCSV(csvText);

// Normalize & build links
function normPath(p) {
  if (!p) return "";
  // keep absolute as-is; otherwise ensure it starts with /
  if (p.startsWith("http")) return p;
  return p.startsWith("/") ? p : "/" + p.replace(/^\.?\//, "");
}

const items = itemsRaw.map((r) => {
  const deposition = r.deposition || r["deposition #"] || r["deposition number"] || "";
  const datablock = r.datablock || r["data block"] || r["data_block"] || "";
  const date = r.date || r["collection date"] || "";
  const doiOrStatus = r.doi_or_status || r.doi || r.status || "";

  // Default link rules (override if CSV provides explicit paths)
  const cifHref = r.cif_path ? normPath(r.cif_path) : `/assets/cifs/${datablock}.cif`;
  const pdfHref = r.pdf_path ? normPath(r.pdf_path) : `/assets/pdfs/${deposition}.pdf`;

  return {
    deposition,
    datablock,
    date,
    doiOrStatus,
    cifHref,
    pdfHref,
  };
}).filter(x => x.deposition || x.datablock);
---

<section class="wrapper">
  <div class="controls">
    <input id="cif-search" type="search" placeholder="Search deposition, datablock, date, DOI/status…" />
  </div>

  <div class="table-wrap">
    <table id="cif-table">
      <thead>
        <tr>
          <th data-key="deposition">Deposition #</th>
          <th data-key="datablock">Datablock</th>
          <th data-key="date">Date</th>
          <th data-key="doiOrStatus">DOI / Status</th>
          <th>Downloads</th>
        </tr>
      </thead>
      <tbody>
        {items.map((row) => (
          <tr>
            <td>{row.deposition}</td>
            <td>{row.datablock}</td>
            <td>{row.date}</td>
            <td>
              {row.doiOrStatus?.startsWith("10.") ? (
                <a href={`https://doi.org/${row.doiOrStatus}`} rel="noopener" target="_blank">{row.doiOrStatus}</a>
              ) : row.doiOrStatus}
            </td>
            <td class="downloads">
              <a href={row.cifHref} download>Download CIF</a>
              <span class="sep">•</span>
              <a href={row.pdfHref} download>PDF</a>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
    <p class="count"><strong>{items.length}</strong> entries</p>
  </div>
</section>

<style>
  .wrapper { display: grid; gap: 1rem; }
  .controls { display: flex; justify-content: flex-end; }
  #cif-search {
    width: min(420px, 100%); padding: .6rem .8rem; border: 1px solid var(--accents-2, #ddd);
    border-radius: .6rem; background: var(--theme-bg, #fff); color: inherit;
  }
  .table-wrap { overflow-x: auto; }
  table { width: 100%; border-collapse: collapse; }
  thead th {
    text-align: left; font-weight: 600; padding: .75rem .75rem; border-bottom: 1px solid var(--accents-2, #e5e7eb);
    cursor: pointer; user-select: none;
  }
  tbody td { padding: .7rem .75rem; border-bottom: 1px solid var(--accents-1, #f1f5f9); vertical-align: top; }
  tbody tr:hover { background: rgba(0,0,0,.03); }
  .downloads a { text-decoration: none; border-bottom: 1px dashed currentColor; }
  .sep { opacity: .5; margin: 0 .4rem; }
  .count { opacity: .7; font-size: .9rem; margin-top: .5rem; }
  @media (max-width: 640px) {
    thead th:nth-child(3), tbody td:nth-child(3) { display:none; } /* hide Date on small screens (optional) */
  }
table {
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed; /* key: forces equal-width columns */
}

thead th,
tbody td {
  width: 20%;          /* 100% ÷ 5 columns = 20% each */
  overflow: hidden;    /* prevent text spilling */
  text-overflow: ellipsis;
  white-space: nowrap; /* optional: keeps in one line */
}
</style>

<script>
  // Simple client-side search & sort (no dependencies)
  (function(){
    const table = document.getElementById('cif-table');
    const tbody = table.querySelector('tbody');
    const rows = Array.from(tbody.querySelectorAll('tr'));
    const search = document.getElementById('cif-search');

    function normalize(t){ return (t || '').toLowerCase(); }

    // Search filter
    search?.addEventListener('input', () => {
      const q = normalize(search.value);
      rows.forEach(tr => {
        const text = normalize(tr.innerText);
        tr.style.display = text.includes(q) ? '' : 'none';
      });
    });

    // Sorting
    let sortState = { key: null, dir: 1 };
    table.querySelectorAll('thead th[data-key]').forEach((th, idx) => {
      th.addEventListener('click', () => {
        const key = th.dataset.key;
        sortState.dir = sortState.key === key ? -sortState.dir : 1;
        sortState.key = key;

        const getCellVal = (tr) => {
          const map = {
            deposition: 0,
            datablock: 1,
            date: 2,
            doiOrStatus: 3
          };
          return tr.children[map[key]]?.innerText.trim() || '';
        };

        const sorted = rows.slice().sort((a,b) => {
          const A = getCellVal(a), B = getCellVal(b);
          const numA = parseFloat(A.replace(/[^\d.]/g,'')), numB = parseFloat(B.replace(/[^\d.]/g,''));
          const bothNumericish = !Number.isNaN(numA) && !Number.isNaN(numB);
          if (bothNumericish) return (numA - numB) * sortState.dir;
          return A.localeCompare(B, undefined, { numeric: true }) * sortState.dir;
        });

        // re-append
        sorted.forEach(tr => tbody.appendChild(tr));
      });
    });
  })();
</script>
