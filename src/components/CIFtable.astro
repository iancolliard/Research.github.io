---
import fs from "node:fs";
import path from "node:path"; // (ok to keep)

const csvFile = new URL("../data/cifs.csv", import.meta.url);

// ---- Minimal CSV parser that supports quoted fields ----
function parseCSV(text) {
  const rows = [];
  let i = 0, field = "", row = [], inQuotes = false;
  while (i <= text.length) {
    const c = text[i] ?? "\n"; // force flush on end
    const next = text[i + 1];

    if (inQuotes) {
      if (c === '"' && next === '"') { field += '"'; i += 2; continue; }
      if (c === '"') { inQuotes = false; i++; continue; }
      field += c; i++; continue;
    }

    if (c === '"') { inQuotes = true; i++; continue; }
    if (c === ",") { row.push(field.trim()); field = ""; i++; continue; }
    if (c === "\n" || c === "\r") {
      if (c === "\r" && next === "\n") i++;
      row.push(field.trim()); field = "";
      if (!(row.length === 1 && row[0] === "")) rows.push(row);
      row = []; i++; continue;
    }

    field += c; i++;
  }
  if (rows.length === 0) return [];
  const header = rows[0].map(h => h.toLowerCase());
  return rows.slice(1).map(r => {
    const obj = {};
    header.forEach((h, idx) => (obj[h] = r[idx] ?? ""));
    return obj;
  });
}

const csvText = fs.readFileSync(csvFile, "utf-8");
const itemsRaw = parseCSV(csvText);

// --- BASE-aware path builder (for GitHub Pages) ---
const BASE = import.meta.env.BASE_URL || "/";

function toBasePath(p) {
  if (!p) return "";
  if (p.startsWith("http")) return p;
  const clean = p.replace(/^\.?\//, "");
  return `${BASE}${clean}`;
}

// Pull first DOI-looking token (e.g. "10.XXXX/YYY")
function pickDOI(str = "") {
  const m = String(str).match(/10\.[^\s;,)]+/);
  return m ? m[0] : "";
}

const items = itemsRaw
  .map((r) => {
    const deposition = r.deposition || r["deposition #"] || r["deposition number"] || "";
    const datablock  = r.datablock  || r["data block"]    || r["data_block"]       || "";
    const date       = r.date        || r["collection date"] || "";

    // status may be separate, or mixed in doi_or_status, etc.
    const rawStatus  = r.status || r.Status || r["doi_or_status"] || r["doi/status"] || "";
    const doiField   = r.doi || "";
    const doi        = doiField || pickDOI(rawStatus);

    // Normalize status label for display & logic
    const lc = String(rawStatus).toLowerCase();
    let status;
    if (lc.includes("submit")) status = "Submitted";
    else if (lc.includes("publish") || doi) status = "Published";
    else status = rawStatus || "";

    // Defaults (override when CSV gives explicit paths)
    const cifHref = r.cif_path ? toBasePath(r.cif_path) : toBasePath(`//assets/cifs/${encodeURIComponent(deposition)}.cif`);
    const pdfHref = r.pdf_path ? toBasePath(r.pdf_path) : toBasePath(`//assets/pdfs/${encodeURIComponent(deposition)}.pdf`);

    return { deposition, datablock, date, status, doi, cifHref, pdfHref };
  })
  .filter((x) => x.deposition || x.datablock);
---

<section class="wrapper">
  <div class="controls">
    <input id="cif-search" type="search" placeholder="Search" />
  </div>

  <div class="table-wrap">
    <table id="cif-table">
      <thead>
        <tr>
          <th data-key="deposition">Deposition #</th>
          <th data-key="datablock">Datablock</th>
          <th data-key="date">Date</th>
          <th data-key="status">Status</th>
          <th>Downloads</th>
        </tr>
      </thead>
      <tbody>
        {items.map((row) => (
          <tr>
            <td>{row.deposition}</td>
            <td>{row.datablock}</td>
            <td>{row.date}</td>
            <td>{row.status}</td>
            <td class="downloads">
              <a href={row.cifHref} download>CIF</a>
              {
                row.status === "Published" && row.doi ? (
                  <a href={`https://doi.org/${row.doi}`} target="_blank" rel="noopener">Open DOI</a>
                ) :
                row.status === "Submitted" ? null :
                (row.pdfHref ? <a href={row.pdfHref} download>PDF</a> : null)
              }
            </td>
          </tr>
        ))}
      </tbody>
    </table>
    <p class="count"><strong>{items.length}</strong> entries</p>
  </div>
</section>

<style>
.wrapper { 
  display: flex; 
  flex-direction: column; 
  align-items: stretch;   /* let child fill the width */
  gap: 1rem; 
}

.table-wrap { 
  overflow-x: auto; 
  width: 100%;            /* full width */
}

table {
  width: 100%;            /* span entire page content area */
  border-collapse: collapse;
  table-layout: fixed;
}

thead th,
tbody td {
  width: 20%; 
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  text-align: center;     /* center cell text */
}

  thead th {
    text-align: center; font-weight: 600; padding: .75rem .75rem;
    border-bottom: 1px solid var(--accents-2, #e5e7eb);
    cursor: pointer; user-select: none;
  }
  tbody td { padding: .7rem .75rem; border-bottom: 1px solid var(--accents-1, #f1f5f9); vertical-align: top; }
  tbody tr:hover { background: rgba(0,0,0,.03); }

  /* Downloads cell: equal-sized buttons */
  .downloads {
    display: flex;
    gap: 0.5rem;
  }
  .downloads a {
    flex: 1;
    text-align: center;
    padding: 0.35rem 0.5rem;
    border: 1px solid var(--accents-2, #ddd);
    border-radius: 0.4rem;
    text-decoration: none;
    background: var(--theme-bg, #f9f9f9);
    white-space: nowrap;
  }

  .count { opacity: .7; font-size: .9rem; margin-top: .5rem; }

  @media (max-width: 640px) {
    thead th:nth-child(3), tbody td:nth-child(3) { display:none; } /* hide Date on small screens (optional) */
  }
  @media (max-width: 520px) {
    .downloads { flex-direction: column; } /* stack nicely on very small screens */
  }
</style>

<script>
  // Simple client-side search & sort (no dependencies)
  (function(){
    const table = document.getElementById('cif-table');
    const tbody = table.querySelector('tbody');
    const rows = Array.from(tbody.querySelectorAll('tr'));
    const search = document.getElementById('cif-search');

    function normalize(t){ return (t || '').toLowerCase(); }

    // Search filter
    search?.addEventListener('input', () => {
      const q = normalize(search.value);
      rows.forEach(tr => {
        const text = normalize(tr.innerText);
        tr.style.display = text.includes(q) ? '' : 'none';
      });
    });

    // Sorting
    let sortState = { key: null, dir: 1 };
    table.querySelectorAll('thead th[data-key]').forEach((th) => {
      th.addEventListener('click', () => {
        const key = th.dataset.key;
        sortState.dir = sortState.key === key ? -sortState.dir : 1;
        sortState.key = key;

        const getCellVal = (tr) => {
          const map = {
            deposition: 0,
            datablock: 1,
            date: 2,
            status: 3
          };
          return tr.children[map[key]]?.innerText.trim() || '';
        };

        const sorted = rows.slice().sort((a,b) => {
          const A = getCellVal(a), B = getCellVal(b);
          const numA = parseFloat(A.replace(/[^\d.]/g,'')), numB = parseFloat(B.replace(/[^\d.]/g,''));
          const bothNumericish = !Number.isNaN(numA) && !Number.isNaN(numB);
          if (bothNumericish) return (numA - numB) * sortState.dir;
          return A.localeCompare(B, undefined, { numeric: true }) * sortState.dir;
        });

        sorted.forEach(tr => tbody.appendChild(tr));
      });
    });
  })();
</script>
